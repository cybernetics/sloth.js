<!doctype html>
<html>
    <head>
        <title>sloth.js</title>
        <meta charset="utf-8">
        <style type="text/css">
            /* shamelessly stolen from http://jashkenas.github.com/docco/ */
            body {
                font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;
                font-size: 15px;
                line-height: 22px;
                color: #252519;
                margin: 0 auto;
                padding: 0;

                width: 960px;
            }

            .toc {
                float: left;
                margin: 10px 0;
                padding: 0;
                padding-top: 20px;
                width: 300px;
            }

            .toc ul {
                padding: 0;
                margin-left: 20px;
            }

            .toc li {
                padding: 0;
            }

            .toc li.title {
                font-weight: bold;
                list-style: none;
                margin-left: -20px;
            }

            .content {
                float: left;
                margin: 10px 0;
                padding-top: 20px;
                width: 620px;
            }

            a {
                color: #261a3b;
            }

            a:visited {
                color: #261a3b;
            }

            p {
                margin: 0 0 15px 0;
            }

            h1, h2, h3, h4, h5, h6 {
                margin: 15px 0 15px 0;
            }

            pre, tt, code {
                font-size: 12px;
                line-height: 18px;
                font-family: Monaco, Consolas, "Lucida Console", monospace;
                margin: 0;
                padding: 0;
            }

            .footer {
                clear: both;
                padding: 20px 0;
                text-align: right;
                font-style: italic;
            }
        </style>
    </head>
    <body>
    <ul class="toc">
        <li class="title">Table of Contents</li>


    
        <li>
        
            <a href="#slothjs">sloth.js</a>
        
        
            <ul>
                
    
        <li>
        
            <a href="#slothify">sloth.ify</a>
        
        
            <ul>
                
    
        <li>
        
            <a href="#Terminology">Terminology</a>
        
        
            <ul>
                
    
        <li>
        
            <a href="#Lazy">Lazy</a>
        
        
        </li>
    
        <li>
        
            <a href="#Strict">Strict</a>
        
        
        </li>
    
        <li>
        
            <a href="#Composable">Composable</a>
        
        
        </li>
    
        <li>
        
            <a href="#Non-composable">Non-composable</a>
        
        
        </li>
    

            </ul>
        
        </li>
    

            </ul>
        
        </li>
    
        <li>
        
            <a href="#Maps-filters-and-folds">Maps, filters and folds</a>
        
        
            <ul>
                
    
        <li>
        
            <a href="#map">map</a>
        
        
        </li>
    
        <li>
        
            <a href="#filter">filter</a>
        
        
        </li>
    
        <li>
        
            <a href="#foldl">foldl</a>
        
        
        </li>
    
        <li>
        
            <a href="#foldr">foldr</a>
        
        
        </li>
    

            </ul>
        
        </li>
    
        <li>
        
            <a href="#Quantification">Quantification</a>
        
        
            <ul>
                
    
        <li>
        
            <a href="#all">all</a>
        
        
        </li>
    
        <li>
        
            <a href="#any">any</a>
        
        
        </li>
    

            </ul>
        
        </li>
    
        <li>
        
            <a href="#Maxima-and-minima">Maxima and minima</a>
        
        
            <ul>
                
    
        <li>
        
            <a href="#max">max</a>
        
        
        </li>
    
        <li>
        
            <a href="#min">min</a>
        
        
        </li>
    

            </ul>
        
        </li>
    
        <li>
        
            <a href="#Taking-and-dropping">Taking and dropping</a>
        
        
            <ul>
                
    
        <li>
        
            <a href="#take">take</a>
        
        
        </li>
    
        <li>
        
            <a href="#drop">drop</a>
        
        
        </li>
    
        <li>
        
            <a href="#takeWhile">takeWhile</a>
        
        
        </li>
    
        <li>
        
            <a href="#dropWhile">dropWhile</a>
        
        
        </li>
    

            </ul>
        
        </li>
    
        <li>
        
            <a href="#Set-operations">Set operations</a>
        
        
            <ul>
                
    
        <li>
        
            <a href="#union">union</a>
        
        
        </li>
    
        <li>
        
            <a href="#intersect">intersect</a>
        
        
        </li>
    
        <li>
        
            <a href="#difference">difference</a>
        
        
        </li>
    
        <li>
        
            <a href="#symmetricDifference">symmetricDifference</a>
        
        
        </li>
    

            </ul>
        
        </li>
    
        <li>
        
            <a href="#Sequence-utilities">Sequence utilities</a>
        
        
            <ul>
                
    
        <li>
        
            <a href="#each">each</a>
        
        
        </li>
    
        <li>
        
            <a href="#concat">concat</a>
        
        
        </li>
    
        <li>
        
            <a href="#product">product</a>
        
        
        </li>
    
        <li>
        
            <a href="#cycle">cycle</a>
        
        
        </li>
    
        <li>
        
            <a href="#nub">nub</a>
        
        
        </li>
    
        <li>
        
            <a href="#enumerate">enumerate</a>
        
        
        </li>
    
        <li>
        
            <a href="#reverse">reverse</a>
        
        
        </li>
    
        <li>
        
            <a href="#sort">sort</a>
        
        
        </li>
    
        <li>
        
            <a href="#group">group</a>
        
        
        </li>
    
        <li>
        
            <a href="#tee">tee</a>
        
        
        </li>
    
        <li>
        
            <a href="#zip">zip</a>
        
        
        </li>
    
        <li>
        
            <a href="#force">force</a>
        
        
        </li>
    

            </ul>
        
        </li>
    
        <li>
        
            <a href="#Advanced-features">Advanced features</a>
        
        
        </li>
    
        <li>
        
            <a href="#Additional-slothifications">Additional slothifications</a>
        
        
            <ul>
                
    
        <li>
        
            <a href="#range">range</a>
        
        
        </li>
    
        <li>
        
            <a href="#repeat">repeat</a>
        
        
        </li>
    

            </ul>
        
        </li>
    
        <li>
        
            <a href="#Iterators">Iterators</a>
        
        
            <ul>
                
    
        <li>
        
            <a href="#iter">iter</a>
        
        
        </li>
    
        <li>
        
            <a href="#iterArray">iterArray</a>
        
        
        </li>
    
        <li>
        
            <a href="#iterString">iterString</a>
        
        
        </li>
    
        <li>
        
            <a href="#iterObject">iterObject</a>
        
        
        </li>
    
        <li>
        
            <a href="#iterNextable">iterNextable</a>
        
        
        </li>
    

            </ul>
        
        </li>
    
        <li>
        
            <a href="#StopIteration">StopIteration</a>
        
        
        </li>
    
        <li>
        
            <a href="#Utility-functions">Utility functions</a>
        
        
            <ul>
                
    
        <li>
        
            <a href="#id">id</a>
        
        
        </li>
    
        <li>
        
            <a href="#cmp">cmp</a>
        
        
        </li>
    
        <li>
        
            <a href="#eq">eq</a>
        
        
        </li>
    

            </ul>
        
        </li>
    

            </ul>
        
        </li>
    

    </ul>
    <div class="content">
<p><a href="https://github.com/rfw/sloth.js"><img style="position: fixed; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"/></a></p>

<h1 id="slothjs">sloth.js</h1>

<p><img src="logo.png" alt="sloth.js" title=""/></p>

<p><em>The lazy JavaScript iterator library.</em></p>

<p><code>sloth.js</code> is a JavaScript library for working with lazy iterators, providing a
way to create, compose and perform various other operations on them — forming a
composable algebra of operations on iterators.</p>

<p><code>sloth.js</code> will be slower than conventional operations for short operations
(though sometimes outperforms native implementations for some inexplicable
reason), but where it shines is consuming large amounts of data along a
pipeline, e.g. combining <code>map</code>, <code>filter</code> and <code>foldl</code> operations. This is 
ecause it doesn't allocate any space before actual iteration.</p>

<p>Inspired by Python's <code>itertools</code> module, Haskell's lazy list facilities
and Jeremy Ashkenas's Underscore.js.</p>

<p><code>sloth.js</code> is freely distributable under the terms of the MIT license.</p>

<h2 id="slothify"><span class="heading">sloth.ify</span> <code>sloth.ify(xs)</code></h2>

<p><code>sloth.ify</code> a sequence <code>xs</code>, returning an object usable with <code>sloth.js</code>
operations. Slothification is an idempotent operation, meaning it can be used
on a slothified variable multiple times without any issue.</p>

<h3 id="Terminology">Terminology</h3>

<h4 id="Lazy">Lazy</h4>

<p>Lazy operations are run as the sequence is iterated, rather than immediately
when the function is called.</p>

<h4 id="Strict">Strict</h4>

<p>Strict operations run as soon as the function is called, allocating space for
it immediately. You may wish to run some strict operations (e.g. <code>reverse</code> and
<code>sort</code>) after forcing, as their in-place native equivalents will be faster.</p>

<h4 id="Composable">Composable</h4>

<p>Composable operations can have successive operations invoked on them, e.g.
<code>map().map().filter().nub()</code>.</p>

<h4 id="Non-composable">Non-composable</h4>

<p>Non-composable operations are found at the end of a <code>sloth.ify</code>ed chain,
usually culminating in a result.</p>

<h2 id="Maps-filters-and-folds">Maps, filters and folds</h2>

<h3 id="map"><span class="heading">map</span> <code>map(f)</code></h3>

<p><code>map</code> applies a function <code>f</code> across all elements of a sequence.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3]).
... map(function(x) { return x + 1; }).force();
[ 2, 3, 4 ]
</code></pre>

<h3 id="filter"><span class="heading">filter</span> <code>filter(f)</code></h3>

<p><code>filter</code> selects elements from a sequence that are <code>true</code> when the predicate
<code>f</code> is applied to them.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3]).
... filter(function(x) { return x &gt; 2; }).force();
[ 3 ]
</code></pre>

<h3 id="foldl"><span class="heading">foldl</span> <code>foldl(f, acc=this.next())</code></h3>

<p><code>foldl</code> is an implementation of the left-fold operation, also known as a
left-reduce or inject.</p>

<p>This is a strict, non-composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3]).
... foldl(function(acc, x) { return acc + x; }, 1);
[ 7 ]
</code></pre>

<h3 id="foldr"><span class="heading">foldr</span> <code>foldr(f, acc=this.next())</code></h3>

<p><code>foldr</code> is an implementation of the right-fold operation, the reverse analog of
the <code>foldl</code> operation.</p>

<p>This operation may be slow due the fact the entire list must first be reversed.</p>

<p>This is a strict, non-composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3]).
... foldr(function(x, acc) { return acc + x; }, 1);
[ 7 ]
</code></pre>

<h2 id="Quantification">Quantification</h2>

<h3 id="all"><span class="heading">all</span> <code>all(f=</code><a href="#id"><code>sloth.id</code></a><code>)</code></h3>

<p><code>all</code> checks if all values in the sequence are truthy or fulfill the predicate
<code>f</code> (universal quantification).</p>

<p>This is a partially strict non-composable operation.</p>

<pre><code>&gt; sloth.ify([true, true, false]).all()
false
</code></pre>

<h3 id="any"><span class="heading">any</span> <code>any(f=</code><a href="#id"><code>sloth.id</code></a><code>)</code></h3>

<p><code>any</code> checks if any values in the sequence are truthy or fulfill the predicate
<code>f</code> (existential quantification).</p>

<p>This is a partially strict non-composable operation.</p>

<pre><code>&gt; sloth.ify([true, true, false]).any()
true
</code></pre>

<h2 id="Maxima-and-minima">Maxima and minima</h2>

<h3 id="max"><span class="heading">max</span> <code>max(f=</code><a href="#cmp"><code>sloth.cmp</code></a><code>)</code></h3>

<p><code>max</code> returns the maximum value of the sequence using the comparison function
<code>f</code>.</p>

<p>If you're looking for the maximum of an array, it is much more efficient to use
<code>Math.max.apply(Math, array)</code> (up to 40x(!!) faster).</p>

<p>This is a strict, non-composable operation.</p>

<pre><code>&gt; sloth.ify([3, 4, 1]).max()
4
</code></pre>

<h3 id="min"><span class="heading">min</span> <code>min(f=</code><a href="#cmp"><code>sloth.cmp</code></a><code>)</code></h3>

<p><code>min</code> returns the minimum value of the sequence using the comparison function
<code>f</code>.</p>

<p>If you're looking for the minimum of an array, it is much more efficient to use
<code>Math.min.apply(Math, array)</code> (up to 40x(!!) faster).</p>

<p>This is a strict, non-composable operation.</p>

<pre><code>&gt; sloth.ify([3, 4, 1]).min()
1
</code></pre>

<h2 id="Taking-and-dropping">Taking and dropping</h2>

<h3 id="take"><span class="heading">take</span> <code>take(n)</code></h3>

<p><code>take</code> yields a sequence with only the first <code>n</code> elements of the original
sequence.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3]).take(2).force();
[ 1, 2 ]
</code></pre>

<h3 id="drop"><span class="heading">drop</span> <code>drop(n)</code></h3>

<p><code>drop</code> yields a sequence without the first <code>n</code> elements of the original
sequence.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3]).drop(2).force();
[ 3 ]
</code></pre>

<h3 id="takeWhile"><span class="heading">takeWhile</span> <code>takeWhile(f)</code></h3>

<p><code>takeWhile</code> yields a sequence with only the first contiguous sequence of
elements that fulfill the predicate <code>f</code>.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3, 1, 2, 3]).
... takeWhile(function(x) { return x &lt; 3; }).force();
[ 1, 2 ]
</code></pre>

<h3 id="dropWhile"><span class="heading">dropWhile</span> <code>dropWhile(f)</code></h3>

<p><code>dropWhile</code> yields a sequence without the first contiguous sequence of elements
that fulfill the predicate <code>f</code>.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3, 1, 2, 3]).
... dropWhile(function(x) { return x &lt; 3; }).force();
[ 3, 1, 2, 3 ]
</code></pre>

<h2 id="Set-operations">Set operations</h2>

<h3 id="union"><span class="heading">union</span> <code>union(ys, f=</code><a href="#eq"><code>sloth.eq</code></a><code>)</code></h3>

<p><code>union</code> yields a sequence with only the unique elements from this sequence and
<code>ys</code>, using the given predicate <code>f</code> for equality.</p>

<p>This will drain the <code>ys</code> iterator.</p>

<p>This can be slow due to the use of <code>nub</code>.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3, 3]).union([3, 4, 4, 5]).force();
[ 1, 2, 3, 4, 5 ]
</code></pre>

<h3 id="intersect"><span class="heading">intersect</span> <code>intersect(ys, f=</code><a href="#eq"><code>sloth.eq</code></a><code>)</code></h3>

<p><code>intersect</code> yields a sequence with only the unique elements present in this
sequence and <code>ys</code>, using the given predicate <code>f</code> for equality.</p>

<p>This will drain the <code>ys</code> iterator.</p>

<p>Again, this can be slow due to the use of <code>nub</code>.</p>

<p>This is a semi-strict composable operation, as it requires the first iterator
to be non-infinite.</p>

<pre><code>&gt; sloth.ify([1, 2, 3, 3]).intersect([3, 4, 4, 5]).force();
[ 3 ]
</code></pre>

<h3 id="difference"><span class="heading">difference</span> <code>difference(ys, f=</code><a href="#eq"><code>sloth.eq</code></a><code>)</code></h3>

<p><code>difference</code> yields a sequence with the elements of sequence <code>ys</code> removed from
this sequence, using the given predicate <code>f</code> for equality.</p>

<p>This will drain the <code>ys</code> iterator.</p>

<p>This does not return only unique elements, but the resulting sequence can be
<code>nub()</code>ed.</p>

<p>This is a semi-strict composable operation, as it requires the second iterator
to be non-infinite.</p>

<pre><code>&gt; sloth.ify([1, 2, 3, 3]).difference([3, 4, 4, 5]).force();
[ 1, 2 ]
</code></pre>

<h3 id="symmetricDifference"><span class="heading">symmetricDifference</span> <code>symmetricDifference(ys, f=</code><a href="#eq"><code>sloth.eq</code></a><code>)</code></h3>

<p><code>symmetricDifference</code> yields a sequence of the elements present in neither this
sequence nor <code>ys</code>, using the given predicate <code>f</code> for equality.</p>

<p>This will drain the <code>ys</code> iterator.</p>

<p>This does not return only unique elements, but the resulting sequence can be
<code>nub()</code>ed.</p>

<p>This is a strict, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3, 3]).
... symmetricDifference([3, 4, 4, 5]).force();
[ 1, 2, 4, 4, 5 ]
</code></pre>

<h2 id="Sequence-utilities">Sequence utilities</h2>

<h3 id="each"><span class="heading">each</span> <code>each(f)</code></h3>

<p><code>each</code> acts as a for-each loop and iterates through all elements of the
sequence, applying the given function <code>f</code> to each. The current index is passed
as the second parameter to <code>f</code>.</p>

<p><a href="#StopIteration"><code>sloth.StopIteration</code></a> can be thrown at any time to break out
of the loop.</p>

<p>This is a strict, non-composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3, 3]).each(console.log);
1 0
2 1
3 2
3 3
</code></pre>

<h3 id="concat"><span class="heading">concat</span> <code>concat(ys)</code></h3>

<p><code>concat</code> joins this sequence with <code>ys</code>, end-to-end.</p>

<p>This will drain the <code>ys</code> iterator.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3]).concat([3, 4, 5]).force();
[1, 2, 3, 3, 4, 5]
</code></pre>

<h3 id="product"><span class="heading">product</span> <code>product(ys, ...)</code></h3>

<p><code>product</code> yields the Cartesian product of all the sequences passed in and this
sequence, equivalent to a series of nested loops.</p>

<p>This will completely drain all iterators.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2]).product([3, 4]).force();
[ [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ] ]
</code></pre>

<h3 id="cycle"><span class="heading">cycle</span> <code>cycle()</code></h3>

<p><code>cycle</code> loops a list around itself infinitely.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2]).cycle().take(6).force();
[ 1, 2, 1, 2, 1, 2 ]
</code></pre>

<h3 id="nub"><span class="heading">nub</span> <code>nub(f=</code><a href="#eq"><code>sloth.eq</code></a><code>)</code></h3>

<p><code>nub</code> removes duplicate elements from the sequence using the given predicate
<code>f</code> for equality.</p>

<p>This is up to 10x slower than Underscore.js's <code>uniq</code>, but is more flexible in
its operation.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 2, 3, 3]).nub().force();
[ 1, 2, 3 ]
</code></pre>

<h3 id="enumerate"><span class="heading">enumerate</span> <code>enumerate()</code></h3>

<p><code>enumerate</code> takes each element and places it in an array with the index as the
first element.</p>

<p>This is a lazy, composable operaton.</p>

<pre><code>&gt; sloth.ify([1, 2, 2, 3, 3]).enumerate().force();
[ [ 0, 1 ], [ 1, 2 ], [ 2, 2 ], [ 3, 3 ], [ 4, 3 ] ]
</code></pre>

<h3 id="reverse"><span class="heading">reverse</span> <code>reverse()</code></h3>

<p><code>reverse</code> yields the reverse iterator of this sequence.</p>

<p>This is a strict, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 2, 3, 3]).reverse().force();
[ 3, 3, 2, 2, 1 ]
</code></pre>

<h3 id="sort"><span class="heading">sort</span> <code>sort(f=</code><a href="#cmp"><code>sloth.cmp</code></a><code>)</code></h3>

<p><code>sort</code> sorts the sequence using the comparison function <code>f</code>.</p>

<p>This is a strict, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 4, 3, 5, 2]).sort().force();
[ 1, 2, 3, 4, 5 ]
</code></pre>

<h3 id="group"><span class="heading">group</span> <code>group(f=</code><a href="#eq"><code>sloth.eq</code></a><code>)</code></h3>

<p><code>group</code> groups the sequence into subsequences using the predicate function <code>f</code>.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 1, 2, 3, 4]).
... group().
... map(function(x) { return x.force() } ).force();
[ [ 1, 1 ], [ 2 ], [ 3 ], [ 4 ] ]
</code></pre>

<h3 id="tee"><span class="heading">tee</span> <code>tee(n=2)</code></h3>

<p><code>tee</code> splits the sequence into <code>n</code> independent sequence iterators.</p>

<p>This may allocate a large amount of additional storage, and <em>will</em> exhibit
unbounded growth on infinite sequences.</p>

<p>The original iterator should not be used.</p>

<p>This is a lazy, non-composable operation.</p>

<pre><code>&gt; iters = sloth.ify([1, 2, 3, 4, 5]).tee();
&gt; iters[0].force();
[ 1, 2, 3, 4, 5 ]
&gt; iters[1].force();
[ 1, 2, 3, 4, 5 ]
</code></pre>

<h3 id="zip"><span class="heading">zip</span> <code>zip(ys, ...)</code></h3>

<p><code>zip</code> takes the sequences passed to it and yields a new sequence taking an
element from each element and placing it into an array. The length of the
resulting sequence is the length of the shortest sequence passed in.</p>

<p>This is somewhat more useful with JavaScript 1.7 destructuring assignment.</p>

<p>This is a lazy, composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3]).zip([2, 3, 4], [3, 4, 5]).force();
[ [ 1, 2, 3 ], [ 2, 3, 4 ], [ 3, 4, 5 ] ]
</code></pre>

<h3 id="force"><span class="heading">force</span> <code>force()</code></h3>

<p><code>force</code> gets all the elements from the iterator and places them into an array.</p>

<p>This is a strict, non-composable operation.</p>

<pre><code>&gt; sloth.ify([1, 2, 3]).force();
[ 1, 2, 3 ]
</code></pre>

<h2 id="Advanced-features">Advanced features</h2>

<p><code>__iterator__</code> implements the iterator protocol for
JavaScript 1.7.</p>

<h2 id="Additional-slothifications">Additional slothifications</h2>

<h3 id="range"><span class="heading">range</span> <code>range(b)</code> or <code>range(a=0, b=Infinity, step=1)</code></h3>

<p>Create a range. Comes in two variants:</p>

<ul>
<li><p>If only a single argument <code>a</code> is provided, an iterator for a range from 0 to
<code>a - 1</code> by a step of 1.</p></li>
<li><p>If all three arguments are specified, a range from <code>a</code> to <code>b - 1</code> is created
by a step of <code>step</code>. If <code>b</code> is <code>null</code>, an infinite range is generated.</p></li>
</ul>

<p>Note that the end of the range does not include <code>b</code> — this is influenced by
Python's <code>range</code> function.</p>

<h3 id="repeat"><span class="heading">repeat</span> <code>repeat(x, n=Infinity)</code></h3>

<p>Repeat an element <code>n</code> times.</p>

<h2 id="Iterators">Iterators</h2>

<p>A lazy iterator in <code>sloth.js</code> is defined as a function (usually a closure)
which can be repeatedly invoked to yield successive values of a sequence, until
the appropriate exception, <a href="#StopIteration"><code>sloth.StopIteration</code></a>, is thrown
to indicate the end of the sequence.</p>

<h3 id="iter"><span class="heading">iter</span> <code>iter(xs)</code></h3>

<p><code>iter</code> creates an low-level iterator for various common data types.</p>

<h3 id="iterArray"><span class="heading">iterArray</span> <code>iterArray(array)</code></h3>

<p>Create an iterator for an array. Note that this is the low-level iterator.</p>

<h3 id="iterString"><span class="heading">iterString</span> <code>iterString(string)</code></h3>

<p>Create an iterator for a string.  Note that this is the low-level iterator.</p>

<h3 id="iterObject"><span class="heading">iterObject</span> <code>iterObject(string)</code></h3>

<p>Create an iterator for an object which yields pairs of keys and values. This
will immediately read in the object and generate a list of its keys and values
and, as such, won't reflect any future changes to the object.</p>

<h3 id="iterNextable"><span class="heading">iterNextable</span> <code>iterNextable(nextable)</code></h3>

<p>Create an iterator for an object with a .next() function (such as generators in
JavaScript 1.7).</p>

<h2 id="StopIteration"><span class="heading">StopIteration</span> <code>StopIteration</code></h2>

<p><code>StopIteration</code> is an object which is thrown to indicate that the iterator has
no more data left to yield, i.e. an end-of-stream situation.</p>

<p>A common example of this reaching the end of an array in a traditional <code>for</code>
loop.</p>

<p>Some JavaScript engines (presently SpiderMonkey) support <code>StopIteration</code>
exceptions.</p>

<p><code>StopIteration</code> instances must <em>not</em> be instantiated --- it is a singleton
exception object which is designed to be thrown as is.</p>

<h2 id="Utility-functions">Utility functions</h2>

<h3 id="id"><span class="heading">id</span> <code>id(x)</code></h3>

<p>A function where, given a value, returns the value (á la Haskell).</p>

<h3 id="cmp"><span class="heading">cmp</span> <code>cmp(a, b)</code></h3>

<p>The default comparison function, combining both lexicographic and
numerical semantics.</p>

<h3 id="eq"><span class="heading">eq</span> <code>eq(a, b)</code></h3>

<p>The default equality function, which returns the strict equality of
two values.</p>
    </div>
    <div class="footer">
        Generated by <a href="http://rfw.github.com/owldoc">Owldoc</a> — a hooting good time!
    </div>
    </body>
</html>
